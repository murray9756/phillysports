// Fantasy Contests API - List and Create Contests
import { getCollection } from '../../lib/mongodb.js';
import { authenticate } from '../../lib/auth.js';

// Roster positions by sport
const ROSTER_POSITIONS = {
    NFL: [
        { position: 'QB', count: 1 },
        { position: 'RB', count: 2 },
        { position: 'WR', count: 3 },
        { position: 'TE', count: 1 },
        { position: 'FLEX', count: 1, eligible: ['RB', 'WR', 'TE'] },
        { position: 'DEF', count: 1, eligible: ['DEF', 'LB', 'DB', 'DL'] }
    ],
    NBA: [
        { position: 'PG', count: 1 },
        { position: 'SG', count: 1 },
        { position: 'SF', count: 1 },
        { position: 'PF', count: 1 },
        { position: 'C', count: 1 },
        { position: 'UTIL', count: 3, eligible: ['PG', 'SG', 'SF', 'PF', 'C'] }
    ],
    MLB: [
        { position: 'P', count: 2, eligible: ['SP', 'RP'] },
        { position: 'C', count: 1 },
        { position: '1B', count: 1 },
        { position: '2B', count: 1 },
        { position: '3B', count: 1 },
        { position: 'SS', count: 1 },
        { position: 'OF', count: 3 }
    ],
    NHL: [
        { position: 'C', count: 2 },
        { position: 'W', count: 3, eligible: ['LW', 'RW'] },
        { position: 'D', count: 2 },
        { position: 'G', count: 1 },
        { position: 'UTIL', count: 1, eligible: ['C', 'LW', 'RW', 'D'] }
    ]
};

const SPORTSDATA_API_KEY = process.env.SPORTSDATA_API_KEY;

// SportsDataIO endpoints for game data
const SPORTSDATA_ENDPOINTS = {
    NFL: 'nfl',
    NBA: 'nba',
    MLB: 'mlb',
    NHL: 'nhl'
};

export default async function handler(req, res) {
    res.setHeader('Access-Control-Allow-Credentials', 'true');
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');

    if (req.method === 'OPTIONS') {
        return res.status(200).end();
    }

    const contestsCollection = await getCollection('fantasy_contests');

    // GET - List contests
    if (req.method === 'GET') {
        try {
            const { sport, status, limit = 20, includeUserEntries } = req.query;

            const query = {};
            if (sport) query.sport = sport;
            if (status) {
                query.status = status;
            } else {
                // Default to upcoming and live contests
                query.status = { $in: ['upcoming', 'live'] };
            }

            const contests = await contestsCollection
                .find(query)
                .sort({ gameDate: 1, createdAt: -1 })
                .limit(parseInt(limit))
                .toArray();

            // If user is logged in and wants their entries
            let userEntries = {};
            if (includeUserEntries === 'true') {
                const user = await authenticate(req);
                if (user) {
                    const entriesCollection = await getCollection('fantasy_entries');
                    const entries = await entriesCollection.find({
                        userId: user._id,
                        contestId: { $in: contests.map(c => c._id) }
                    }).toArray();

                    entries.forEach(e => {
                        userEntries[e.contestId.toString()] = e;
                    });
                }
            }

            return res.status(200).json({
                success: true,
                contests: contests.map(c => ({
                    ...c,
                    userEntry: userEntries[c._id.toString()] || null
                }))
            });
        } catch (error) {
            console.error('List contests error:', error);
            return res.status(500).json({ error: 'Internal server error' });
        }
    }

    // POST - Create contest (admin only or auto-generation)
    if (req.method === 'POST') {
        try {
            const { sport, date, entryFee = 0, prizePool = 100, title, isAutoGenerated } = req.body;

            // Validate sport
            if (!sport || !['NFL', 'NBA', 'MLB', 'NHL'].includes(sport)) {
                return res.status(400).json({ error: 'Invalid sport' });
            }

            if (!SPORTSDATA_API_KEY) {
                return res.status(500).json({ error: 'SportsDataIO API key not configured' });
            }

            // Get games for the date from SportsDataIO
            const targetDate = date || new Date().toISOString().split('T')[0];
            const endpoint = SPORTSDATA_ENDPOINTS[sport];
            const gamesUrl = `https://api.sportsdata.io/v3/${endpoint}/scores/json/GamesByDate/${targetDate}?key=${SPORTSDATA_API_KEY}`;

            const gamesResponse = await fetch(gamesUrl);
            if (!gamesResponse.ok) {
                console.error('SportsDataIO games fetch failed:', gamesResponse.status);
                return res.status(400).json({ error: 'Failed to fetch games from SportsDataIO' });
            }

            const gamesData = await gamesResponse.json();

            if (!gamesData || gamesData.length === 0) {
                return res.status(400).json({ error: 'No games found for this date' });
            }

            // Get game IDs and game times from SportsDataIO
            // SportsDataIO returns times in Eastern Time without timezone suffix
            const gameIds = gamesData.map(g => (g.GameID || g.ScoreID)?.toString());
            const gameTimes = gamesData
                .map(g => {
                    const dt = g.DateTime || g.Day;
                    if (!dt) return null;
                    // If no timezone in string, treat as Eastern Time
                    if (!dt.includes('Z') && !dt.includes('+') && !dt.includes('-', 10)) {
                        return new Date(dt + '-05:00'); // Append EST offset
                    }
                    return new Date(dt);
                })
                .filter(d => d && !isNaN(d.getTime()))
                .sort((a, b) => a - b);
            const earliestGame = gameTimes[0] || new Date(targetDate + 'T18:00:00-05:00');
            const latestGame = gameTimes[gameTimes.length - 1] || earliestGame;

            // Generate title if not provided
            const contestTitle = title || `${sport} ${targetDate} - ${entryFee === 0 ? 'Free' : `$${entryFee}`} Contest`;

            // Prize structure (simple winner-take-all or tiered)
            let prizeStructure;
            if (prizePool <= 100) {
                prizeStructure = [{ place: 1, amount: prizePool }];
            } else {
                prizeStructure = [
                    { place: 1, amount: Math.floor(prizePool * 0.5) },
                    { place: 2, amount: Math.floor(prizePool * 0.3) },
                    { place: 3, amount: Math.floor(prizePool * 0.2) }
                ];
            }

            const contest = {
                sport,
                title: contestTitle,
                // Store as noon EST to ensure correct date display
                gameDate: new Date(targetDate + 'T12:00:00-05:00'),
                gameDateString: targetDate, // Also store the string for easy access
                gameIds,
                salaryCap: 50000,
                rosterPositions: ROSTER_POSITIONS[sport],
                entryFee: parseInt(entryFee),
                maxEntries: 3, // Per user
                maxTotalEntries: 1000,
                prizePool: parseInt(prizePool),
                prizeStructure,
                status: 'upcoming',
                entryCount: 0,
                createdAt: new Date(),
                locksAt: earliestGame,
                endsAt: latestGame,
                isAutoGenerated: isAutoGenerated || false
            };

            const result = await contestsCollection.insertOne(contest);

            return res.status(201).json({
                success: true,
                contest: {
                    _id: result.insertedId,
                    ...contest
                }
            });
        } catch (error) {
            console.error('Create contest error:', error);
            return res.status(500).json({ error: 'Internal server error' });
        }
    }

    return res.status(405).json({ error: 'Method not allowed' });
}
