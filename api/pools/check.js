// Block Pools Cron - Auto-create pools, fill squares, update scores, pay winners
import { getCollection } from '../lib/mongodb.js';
import { fetchScoreboard } from '../lib/espn.js';

// Period markers for each sport
const PERIOD_MARKERS = {
    NFL: ['Q1', 'Q2', 'Q3', 'Q4', 'Final'],
    NBA: ['Q1', 'Q2', 'Q3', 'Q4', 'Final'],
    NHL: ['P1', 'P2', 'P3', 'Final'],
    MLB: ['3rd', '6th', '9th', 'Final']
};

// Payout keys for each sport
const PAYOUT_KEYS = {
    NFL: { 'Q1': 'q1', 'Q2': 'q2', 'Q3': 'q3', 'Q4': 'q4', 'Final': 'final' },
    NBA: { 'Q1': 'q1', 'Q2': 'q2', 'Q3': 'q3', 'Q4': 'q4', 'Final': 'final' },
    NHL: { 'P1': 'p1', 'P2': 'p2', 'P3': 'p3', 'Final': 'final' },
    MLB: { '3rd': 'i3', '6th': 'i6', '9th': 'i9', 'Final': 'final' }
};

// Default payout structures by sport
const DEFAULT_PAYOUTS = {
    NFL: { q1: 20, q2: 20, q3: 20, q4: 20, final: 20 },
    NBA: { q1: 20, q2: 20, q3: 20, q4: 20, final: 20 },
    NHL: { p1: 25, p2: 25, p3: 25, final: 25 },
    MLB: { i3: 15, i6: 15, i9: 35, final: 35 }
};

// Philly teams config
const PHILLY_TEAMS = {
    NFL: ['eagles', 'philadelphia eagles'],
    NBA: ['76ers', 'sixers', 'philadelphia 76ers'],
    MLB: ['phillies', 'philadelphia phillies'],
    NHL: ['flyers', 'philadelphia flyers']
};

function isPhillyTeam(teamName, sport) {
    if (!teamName) return false;
    const normalized = teamName.toLowerCase();
    const patterns = PHILLY_TEAMS[sport] || [];
    return patterns.some(p => normalized.includes(p));
}

function shuffleArray(arr) {
    const shuffled = [...arr];
    for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
}

export default async function handler(req, res) {
    res.setHeader('Access-Control-Allow-Credentials', 'true');
    res.setHeader('Access-Control-Allow-Origin', '*');

    if (req.method !== 'GET' && req.method !== 'POST') {
        return res.status(405).json({ error: 'Method not allowed' });
    }

    try {
        const poolsCollection = await getCollection('block_pools');
        const usersCollection = await getCollection('users');

        const results = {
            poolsCreated: 0,
            poolsProcessed: 0,
            squaresFilled: 0,
            winnersAwarded: 0,
            errors: []
        };

        const now = new Date();
        const tenMinutesFromNow = new Date(now.getTime() + 10 * 60 * 1000);

        // ============================================
        // STEP 1: Auto-create pools for today's Philly games
        // ============================================
        const sports = ['NFL', 'NBA', 'NHL', 'MLB'];

        for (const sport of sports) {
            try {
                const games = await fetchScoreboard(sport);

                for (const game of games) {
                    // Check if this is a Philly game
                    const isPhillyGame = isPhillyTeam(game.homeTeam, sport) || isPhillyTeam(game.awayTeam, sport);
                    if (!isPhillyGame) continue;

                    // Check if game is today and not already completed
                    if (game.isFinal) continue;

                    const gameTime = new Date(game.gameDate);
                    const today = new Date();
                    today.setHours(0, 0, 0, 0);
                    const gameDateOnly = new Date(gameTime);
                    gameDateOnly.setHours(0, 0, 0, 0);

                    if (gameDateOnly.getTime() !== today.getTime()) continue;

                    // Check if pool already exists for this game
                    const existingPool = await poolsCollection.findOne({
                        gameId: game.espnId,
                        sport: sport
                    });

                    if (existingPool) continue;

                    // Create new pool
                    const poolTitle = `${game.awayTeam} @ ${game.homeTeam} Squares`;

                    const newPool = {
                        gameId: game.espnId,
                        sport,
                        homeTeam: game.homeTeam,
                        awayTeam: game.awayTeam,
                        gameTime: gameTime,
                        title: poolTitle,
                        squarePrice: 10,
                        maxPerUser: 10,
                        creatorId: null,
                        creatorName: 'PhillySports.com',
                        isAutoGenerated: true,
                        rowNumbers: null,
                        colNumbers: null,
                        numbersAssigned: false,
                        squares: [],
                        squaresSold: 0,
                        payouts: DEFAULT_PAYOUTS[sport],
                        winners: [],
                        status: 'open',
                        prizePool: 0,
                        currentScore: { home: 0, away: 0 },
                        createdAt: now,
                        updatedAt: now
                    };

                    await poolsCollection.insertOne(newPool);
                    results.poolsCreated++;
                    console.log(`Created pool for ${sport}: ${poolTitle}`);
                }
            } catch (error) {
                console.error(`Error checking ${sport} games:`, error);
                results.errors.push({ sport, error: error.message });
            }
        }

        // ============================================
        // STEP 2: Process existing pools
        // ============================================
        const pools = await poolsCollection.find({
            status: { $in: ['open', 'locked', 'live'] }
        }).toArray();

        for (const pool of pools) {
            try {
                const updates = {};
                const gameTime = new Date(pool.gameTime);
                const lockTime = new Date(gameTime.getTime() - 10 * 60 * 1000); // 10 min before

                // ----------------------------------------
                // Lock pool and fill squares 10 min before game
                // ----------------------------------------
                if (pool.status === 'open' && now >= lockTime) {
                    // Fill empty squares with House bot
                    const existingSquares = new Set(
                        (pool.squares || []).map(s => `${s.row}-${s.col}`)
                    );

                    const newSquares = [];
                    for (let row = 0; row < 10; row++) {
                        for (let col = 0; col < 10; col++) {
                            if (!existingSquares.has(`${row}-${col}`)) {
                                newSquares.push({
                                    row,
                                    col,
                                    userId: null,
                                    username: 'House',
                                    isHouse: true,
                                    purchasedAt: now
                                });
                                results.squaresFilled++;
                            }
                        }
                    }

                    if (newSquares.length > 0) {
                        await poolsCollection.updateOne(
                            { _id: pool._id },
                            {
                                $push: { squares: { $each: newSquares } },
                                $inc: { squaresSold: newSquares.length }
                            }
                        );
                    }

                    // Assign random numbers
                    updates.rowNumbers = shuffleArray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);
                    updates.colNumbers = shuffleArray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);
                    updates.numbersAssigned = true;
                    updates.status = 'locked';
                    updates.lockedAt = now;

                    console.log(`Locked pool: ${pool.title}`);
                }

                // ----------------------------------------
                // Fetch live scores and update
                // ----------------------------------------
                if (pool.gameId && (pool.status === 'locked' || pool.status === 'live')) {
                    const games = await fetchScoreboard(pool.sport);
                    const game = games.find(g => g.espnId === pool.gameId);

                    if (game) {
                        updates.currentScore = {
                            home: game.homeScore || 0,
                            away: game.awayScore || 0
                        };

                        if (game.isInProgress && pool.status !== 'live') {
                            updates.status = 'live';
                        }

                        // Get current pool state with any updates
                        const currentPool = {
                            ...pool,
                            ...updates,
                            rowNumbers: updates.rowNumbers || pool.rowNumbers,
                            colNumbers: updates.colNumbers || pool.colNumbers
                        };

                        // ----------------------------------------
                        // Check for period endings and award prizes
                        // ----------------------------------------
                        const periodPayouts = PAYOUT_KEYS[pool.sport] || {};
                        const existingWinners = new Set(
                            (pool.winners || []).map(w => w.period)
                        );

                        // Determine current period from status
                        const statusDesc = game.statusDescription || '';
                        let completedPeriods = [];

                        if (pool.sport === 'NFL' || pool.sport === 'NBA') {
                            if (statusDesc.includes('End') || statusDesc.includes('Half')) {
                                if (statusDesc.includes('1st') || statusDesc.includes('Q1')) completedPeriods.push('Q1');
                                if (statusDesc.includes('Half') || statusDesc.includes('2nd') || statusDesc.includes('Q2')) completedPeriods.push('Q2');
                                if (statusDesc.includes('3rd') || statusDesc.includes('Q3')) completedPeriods.push('Q3');
                            }
                            if (game.isFinal) completedPeriods = ['Q1', 'Q2', 'Q3', 'Q4', 'Final'];
                        } else if (pool.sport === 'NHL') {
                            if (statusDesc.includes('End')) {
                                if (statusDesc.includes('1st')) completedPeriods.push('P1');
                                if (statusDesc.includes('2nd')) completedPeriods.push('P2');
                            }
                            if (game.isFinal) completedPeriods = ['P1', 'P2', 'P3', 'Final'];
                        } else if (pool.sport === 'MLB') {
                            // MLB - check inning
                            const inningMatch = statusDesc.match(/(\d+)/);
                            const inning = inningMatch ? parseInt(inningMatch[1]) : 0;
                            if (inning >= 3 && statusDesc.includes('End')) completedPeriods.push('3rd');
                            if (inning >= 6 && statusDesc.includes('End')) completedPeriods.push('6th');
                            if (game.isFinal) completedPeriods = ['3rd', '6th', '9th', 'Final'];
                        }

                        // Award winners for completed periods
                        const newWinners = [];
                        for (const period of completedPeriods) {
                            if (existingWinners.has(period)) continue;

                            const payoutKey = periodPayouts[period];
                            const payoutPercent = currentPool.payouts?.[payoutKey] || 0;
                            const payoutAmount = Math.floor((currentPool.prizePool || 0) * (payoutPercent / 100));

                            // Get the score at end of this specific period (not final score!)
                            const periodScore = game.periodScores?.[period] || { home: game.homeScore, away: game.awayScore };
                            const homeDigit = periodScore.home % 10;
                            const awayDigit = periodScore.away % 10;

                            // Find row/col index for these digits
                            const rowIndex = currentPool.rowNumbers?.indexOf(homeDigit);
                            const colIndex = currentPool.colNumbers?.indexOf(awayDigit);

                            if (rowIndex !== undefined && rowIndex >= 0 && colIndex !== undefined && colIndex >= 0) {
                                const winningSquare = (currentPool.squares || []).find(
                                    s => s.row === rowIndex && s.col === colIndex
                                );

                                if (winningSquare) {
                                    const winner = {
                                        period,
                                        homeScore: periodScore.home,
                                        awayScore: periodScore.away,
                                        winningRow: rowIndex,
                                        winningCol: colIndex,
                                        winningDigits: { home: homeDigit, away: awayDigit },
                                        userId: winningSquare.userId,
                                        username: winningSquare.username,
                                        isHouse: winningSquare.isHouse || false,
                                        payout: payoutAmount,
                                        paidAt: now
                                    };

                                    newWinners.push(winner);

                                    // Pay winner if not House
                                    if (winningSquare.userId && !winningSquare.isHouse && payoutAmount > 0) {
                                        await usersCollection.updateOne(
                                            { _id: winningSquare.userId },
                                            { $inc: { coinBalance: payoutAmount } }
                                        );
                                        results.winnersAwarded++;
                                        console.log(`Paid ${winningSquare.username} ${payoutAmount} coins for ${period}`);
                                    }
                                }
                            }
                        }

                        if (newWinners.length > 0) {
                            await poolsCollection.updateOne(
                                { _id: pool._id },
                                { $push: { winners: { $each: newWinners } } }
                            );
                        }

                        // Mark as completed if game is final
                        if (game.isFinal) {
                            updates.status = 'completed';
                            updates.completedAt = now;
                            console.log(`Completed pool: ${pool.title}`);
                        }
                    }
                }

                // Apply updates
                if (Object.keys(updates).length > 0) {
                    updates.updatedAt = now;
                    await poolsCollection.updateOne(
                        { _id: pool._id },
                        { $set: updates }
                    );
                }

                results.poolsProcessed++;
            } catch (error) {
                console.error(`Error processing pool ${pool._id}:`, error);
                results.errors.push({
                    poolId: pool._id.toString(),
                    error: error.message
                });
            }
        }

        return res.status(200).json({
            success: true,
            ...results,
            checkedAt: now
        });
    } catch (error) {
        console.error('Pools check error:', error);
        return res.status(500).json({ error: 'Internal server error' });
    }
}
